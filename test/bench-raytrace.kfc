(%testspec
 (%tags bench))
(module
  (import random)
  (import graphics)
  (import rt)

  (define-datatype ray-result
    (miss)
    ;; The ray hits the surface and is completely absorbed, so it
    ;; should be rendered with the returned color.
    ;;
    ;; the float tells the distance so we can do occlusion when
    ;; multiple rays hit.
    (hit float point3f-t))

  (define (minimum a b)
    (if (< a b) a b))
  (define (maximum a b)
    (if (> a b) a b))

  (define (make-diffuse-sphere center radius color)
    ;; x and y are switched for some reason from how I think light
    ;; should work.
    (let ((light-dir (unit-length (point3f 1 1 2))))
      ;;(println light-dir)
      (lambda (start direction)
        ;; Sphere / Ray interstion code adapted from
        ;; http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection
        (let ((a (dot-prod direction direction))
              (b (* 2 (dot-prod direction start)))
              (c (- (dot-prod start start) (* radius radius))))
          (let ((disc (- (* b b) (* 4 (* a c)))))
            (if (< disc 0)
                (miss)
                (let* ((dist-sqrt (sqrt disc))
                       (q (if (< b 0)
                              (* -0.5 (+ b dist-sqrt))
                              (* 0.5 (- dist-sqrt b))))
                       (t0 (/ q a))
                       (t1 (/ c q)))
                  (let ((t (maximum t0 t1)))
                    (if (< t 0)
                        (miss)
                        (let* ((pos (point-add (point-scale direction t)
                                               start))
                               (norm (unit-length (point-diff pos center)))
                               (color (point-scale
                                       color
                                       (dot-prod light-dir norm))))
                          (hit t color)))))))))))

  (define-macro interpolate-range ()
    ((_ (i start end steps) body)
     (kernel ((j (iota steps)))
       (let ((i (+ start (* (/ (- end start) (int->float steps))
                            (int->float j)))))
         body))))

  (define (translate object amount)
    (lambda (start dir)
      (object (point-diff start amount) dir)))

  (define (scale object amount)
    (lambda (start dir)
      (object (point-div start amount) dir)))
  
  (define (select-closest a b)
    (match a
      ((miss) b)
      ((hit da _)
       (match b
         ((miss) a)
         ((hit db _)
          (if (< da db) a b))))))

  (define (rand->float x)
    (/ (int->float (mod x 1000000)) 1e6))

  (define-macro random-floats ()
    ((_ rng () e ...)
     (begin e ...))
    ((_ rng (x x* ...) e ...)
     (let ((r^ rng))
       (match (random r^)
         ((RandomResult i r^)
          (let ((x (rand->float i)))
            (random-floats r^ (x* ...) e ...)))))))
       
  
  (define (make-scale-translate n rng)
    (kernel ((i (iota n)))
      (random-floats
       (reseed rng i)
       (s tx ty tz r g b radius)
       (scale
        (translate
         (make-diffuse-sphere (point3f 0 0 0)
                              radius
                              (point3f r g b))
         (point3f (* 4.0 tx) (* 4.0 ty) (* 4.0 tz)))
        s))))

  (define (make-translate-scale n rng)
    (kernel ((i (iota n)))
      (random-floats
       (reseed rng i)
       (s tx ty tz r g b radius)
       (translate
        (scale (make-diffuse-sphere (point3f 0 0 0)
                                    radius
                                    (point3f r g b))
        
               s)
        (point3f (* 4.0 tx) (* 4.0 ty) (* 4.0 tz))))))

  (define (mix-scene n lefts rights)
    (kernel ((i (iota (* n 2))))
      (if (= 0 (mod i 2))
          (vector-ref lefts  (/ i 2))
          (vector-ref rights (/ i 2)))))

  (define (append lefts rights)
    (let ((len (length lefts)))
      (kernel ((i (iota (+ len (length rights)))))
        (if (< i len)
            (vector-ref lefts i)
            (vector-ref rights (- i len))))))

  (define (render-image scene origin width height)
    (interpolate-range
     (y 1.0 -1.0 height) ;; y coordinate is upside down.
     (interpolate-range
      (x -1.0 1.0 width)
      (let ((dir (unit-length (point3f x y 1))))
        (match (reduce select-closest
                 (kernel ((object scene))
                   (object origin dir)))
          ((miss) (point3f 0 0 0))
          ((hit dist color) color))))))

  (define (do-iteration scene origin width height)
    (let* ((start (nanotime))
           (img (render-image scene origin width height))
           (stop (nanotime)))
      (write-ppm "test.bin/raytrace-converged.ppm"
                 (map2d (lambda (x) (rgbf->rgbi x)) img))
      (println* "    - " (elapsed-sec start stop))))
  
  (define (main)
    (println "name: raytrace")
    (println* "device_type: " (match (rt-device-type)
                                ((CPU) "cpu")
                                ((GPU) "gpu")))
    (let ((args (command-line)))
      (let ((convergent (if (>= (length args) 2)
                            (parse-str->int (vector-ref args 1) 0)
                            0))
            (num-bodies (if (>= (length args) 3)
                            (parse-str->int (vector-ref args 2) 10)
                            10))
            (num-trials (if (>= (length args) 4)
                            (parse-str->int (vector-ref args 3) 4)
                            4))
            (rng (init-rand)))
      (let ((lefts  (make-scale-translate num-bodies rng))
            (rights (make-translate-scale num-bodies rng))
            (width 512)
            (height 512)
            (origin (point3f 0 0 -5)))
        (if (= convergent 1)
            (let ((scene (append lefts rights)))
              (println "variant: convergent")
              (println "results:")
              (println* "- num_bodies: " num-bodies)
              (println* "  raw_data:")
              (println* "    total_time:")
              (for (i 0 num-trials)
                (do-iteration scene origin width height)))
            (let ((scene (mix-scene (length lefts) lefts rights)))
              (println "variant: divergent")
              (println "results:")
              (println* "- num_bodies: " num-bodies)
              (println* "  raw_data:")
              (println* "    total_time:")
              (for (i 0 num-trials)
                (do-iteration scene origin width height)))))))
    0))

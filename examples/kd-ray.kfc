(module
    (import vectors)
    (import graphics)
    
    (define-macro interpolate-range ()
      ((_ (i start end steps) body)
       (kernel ((j (iota steps)))
         (let ((i (+ start (* (/ (- end start) (int->float steps))
                              (int->float j)))))
           body))))
    
    (define-datatype Shape
      ;; (Sphere center-x center-y center-z radius color)
      (Sphere float float float float point3f-t))
    
    (define-datatype Axis
      (XAxis)
      (YAxis)
      (ZAxis))

    (define-datatype ray-result
      (miss)
      ;; The ray hits the surface and is completely absorbed, so it
      ;; should be rendered with the returned color.
      ;;
      ;; the float tells the distance so we can do occlusion when
      ;; multiple rays hit.
      (hit float point3f-t))

  (define-datatype KdTree
    (Leaf (vec Shape))
    (Split Axis float KdTree KdTree))

  (define-datatype Range-t
    ;; (Range low high)
    (Range float float))

  (define (minimum a b)
    (if (< a b) a b))
  (define (maximum a b)
    (if (> a b) a b))


  ;; (Shape Axis) -> Range
  (define (bounding-box shape axis)
    (match shape
      ((Sphere cx cy cz r color)
       (match axis
         ((XAxis) (Range (- cx r) (+ cx r)))
         ((YAxis) (Range (- cy r) (+ cy r)))
         ((ZAxis) (Range (- cz r) (+ cz r)))))))

  (define (full-bounding-box shape)
    (BoxDims (bounding-box shape (XAxis))
             (bounding-box shape (YAxis))
             (bounding-box shape (ZAxis))))
  
  (define (empty-tree)
    (Leaf (vector)))

  (define (left-of? axis plane shape)
    (match (bounding-box shape axis)
      ((Range low high)
       (<= high plane))))

  (define (right-of? axis plane shape)
    (match (bounding-box shape axis)
      ((Range low high)
       (>= low plane))))

  (define (insert-tree tree shape)
    (match tree
      ((Leaf shapes)
       (Leaf (vector-append shapes (vector shape))))
      ((Split axis plane left right)
       (let ((left (if (left-of? axis plane shape)
                       (insert-tree left shape)
                       left))
             (right (if (right-of? axis plane shape)
                        (insert-tree right shape)
                        right)))
         (Split axis plane left right)))))

  ;; Returns the "ideal" leaf size.
  (define (leaf-size) 10)

  (define-datatype BoxDims-t
    ;; (BoxDims x y z)
    (BoxDims Range-t Range-t Range-t))

  (define (union-range (Range low-a high-a) b)
    (match b
      ((Range low-b high-b)
       (Range (min low-a low-b) (max high-a high-b)))))

  (define (union-box (BoxDims ax ay az) b)
    (match b
      ((BoxDims bx by bz)
       (BoxDims (union-range ax bx) (union-range ay by) (union-range az bz)))))

  (define (box-surface-area (BoxDims x y z))
    (let ((x (match x
               ((Range low high) (- high low))))
          (y (match y
               ((Range low high) (- high low))))
          (z (match z
               ((Range low high) (- high low)))))
      (* 2 (+ (* x y)
              (+ (* y z)
                 (* x z))))))

  (define-datatype SplitCost-t
    ;; (SplitScore axis plane cost)
    (SplitCost Axis float float))

  (define-datatype IntPair-t
    (IntPair int int))

  (define (IntPair+ (IntPair a1 a2) b)
    (match b
      ((IntPair b1 b2)
       (IntPair (+ a1 b1) (+ a2 b2)))))

  (define-datatype FloatPair-t
    (FloatPair float float))
  
  (define (traversal-cost)
    1.0)
  (define (intersection-cost)
    1.0)
  
  (define (eval-split axis plane (FloatPair left-area right-area) shapes)
    ;; I would love to use regular reduce here, but otherwise we end up
    ;; with kernels calling functions that have kernels.
    (let ((counts (inner-reduce IntPair+
                    (kernel ((shape shapes))
                      (IntPair (if (left-of?  axis plane shape) 1 0)
                               (if (right-of? axis plane shape) 1 0))))))
      (match counts
        ((IntPair left right)
         (+ (+ (traversal-cost)
               (* (* left-area (int->float left))
                  (intersection-cost)))
            (+ (traversal-cost)
               (* (* right-area (int->float right))
                  (intersection-cost))))))))

  ;; We have to make this a macro to keep kernels out of kernels.
  #;(define-macro eval-split ()
    ((_ axis plane areas shapes)
     (match areas
       ((FloatPair left-area right-area)
        (let ((counts (reduce IntPair+
                        (kernel ((shape shapes))
                          (IntPair (if (left-of?  axis plane shape) 1 0)
                                   (if (right-of? axis plane shape) 1 0))))))
          (match counts
            ((IntPair left right)
             (+ (+ (traversal-cost)
                   (* (* left-area (int->float left))
                      (intersection-cost)))
                (+ (traversal-cost)
                   (* (* right-area (int->float right))
                      (intersection-cost)))))))))))
  
  (define (best-split a b)
    (match a
      ((SplitCost _ _1 a-cost)
       (match b
         ((SplitCost _ _1 b-cost)
          (if (< a-cost b-cost) a b))))))

  (define-datatype BoxPair-t
    (BoxPair BoxDims-t BoxDims-t))

  ;; Assumes plane is in the appropriate range
  (define (split-box (BoxDims x y z) axis plane)
    (match axis
      ((XAxis)
       (match x
         ((Range low high)
          (BoxPair (BoxDims (Range low plane)  y z)
                   (BoxDims (Range plane high) y z)))))
      ((YAxis)
       (match y
         ((Range low high)
          (BoxPair (BoxDims x (Range low plane)  z)
                   (BoxDims x (Range plane high) z)))))
      ((ZAxis)
       (match z
         ((Range low high)
          (BoxPair (BoxDims x y (Range low plane))
                   (BoxDims x y (Range plane high))))))))

  (define (find-split dims shapes axis)
    (reduce best-split
      (kernel ((shape shapes))
        (match (bounding-box shape axis)
          ((Range left right)
           (best-split (SplitCost axis
                                  left
                                  (eval-split axis
                                              left
                                              (match (split-box dims axis left)
                                                ((BoxPair left right)
                                                 (FloatPair (box-surface-area left)
                                                            (box-surface-area right))))
                                              shapes))
                       (SplitCost axis
                                  right
                                  (eval-split axis
                                              right
                                              (match (split-box dims axis right)
                                                ((BoxPair left right)
                                                 (FloatPair (box-surface-area left)
                                                            (box-surface-area
                                                             right))))
                                              shapes))))))))

  ;; Bottom up approach to tree building.
  ;;
  ;; This is based on some pseudo code from
  ;; http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_7_Kd-Trees_and_More_Speed.shtml
  (define (build-tree shapes dims)
    (println shapes)
    (if (> (length shapes) 0)
        (let ((nosplit-cost (* (box-surface-area dims)
                               (* (int->float (length shapes))
                                  (intersection-cost))))
              (best-x (find-split dims shapes (XAxis)))
              (best-y (find-split dims shapes (YAxis)))
              (best-z (find-split dims shapes (ZAxis))))
          (println* "Best X split:  " best-x)
          (println* "Best Y split:  " best-y)
          (println* "Best Z split:  " best-z)
          (println* "No-split cost: " nosplit-cost)
          (match (best-split best-x (best-split best-y best-z))
            ((SplitCost axis plane cost)
             (println* "Splitting along " axis)
             (if (< cost nosplit-cost)
                 (let ((lefts (filter (lambda (shape)
                                        (left-of? axis plane shape))
                                      shapes))
                       (rights (filter (lambda (shape)
                                         (right-of? axis plane shape))
                                       shapes)))
                   (match (split-box dims axis plane)
                     ((BoxPair left-box right-box)
                      (Split axis plane
                             (build-tree lefts left-box)
                             (build-tree rights right-box)))))
                 (Leaf shapes)))))
        (Leaf (vector))))

  (define (print-tree tree)
    (match tree
      ((Leaf shapes)
       (print* "(Leaf " shapes ")") 0)
      ((Split axis plane left right)
       (print* "(Split " axis " " plane " ")
       (print-tree left)
       (print " ")
       (print-tree right)
       (print ")") 0)))
  
  (define (main)
    (let* ((shapes (vector (Sphere -10 -10  10 3 (point3f 1 1 1))
                           (Sphere -10  10 -10 3 (point3f 1 1 0))
                           (Sphere -10  10  10 3 (point3f 1 0 1))
                           (Sphere  10 -10 -10 3 (point3f 1 0 0))
                           (Sphere  10 -10  10 3 (point3f 0 1 1))
                           (Sphere  10  10 -10 3 (point3f 0 1 0))
                           (Sphere  10  10  10 3 (point3f 0 0 1))
                           (Sphere -10 -10 -10 3 (point3f 0.5 0.5 0.5))))
           (origin (point3f 3 3 -25))
           (width  256)
           (height 256)
           (dims (reduce union-box
                   (kernel ((shape shapes)) (full-bounding-box shape)))))
      (println dims)
      (let ((tree (build-tree shapes dims)))
        (print-tree tree) (println "")
        (let ((image (render-tree tree origin width height)))
          (write-ppm "test.bin/kd-ray-traverse.ppm"
                     (map2d (lambda (x) (rgbf->rgbi x)) image))))
      (let ((image (render-direct shapes origin width height)))
        (write-ppm "test.bin/kd-ray-direct.ppm"
                   (map2d (lambda (x) (rgbf->rgbi x)) image))))
    0)

  (define (select-closest a b)
    (match a
      ((miss) b)
      ((hit da _)
       (match b
         ((miss) a)
         ((hit db _)
          (if (< da db) a b))))))

  (define (intersect-shape shape origin direction light-dir)
    (match shape
      ;; This is updated from
      ;; http://www.ccs.neu.edu/home/fell/CSU540/programs/RayTracingFormulas.htm
      ((Sphere cx cy cz radius color)
       (let ((center (point3f cx cy cz)))
         (let ((a (dot-prod direction direction))
               (b (* 2 (dot-prod direction (point-diff origin center))))
               (c (- (- (+ (dot-prod origin origin)
                           (dot-prod center center))
                        (* 2 (dot-prod center origin)))
                     (* radius radius))))
           (let ((disc (- (* b b) (* 4 (* a c)))))
             (if (< disc 0)
                 (miss)
                 (let* ((disc-sqrt (sqrt disc))
                        #;(q (if (< b 0)
                               (* -0.5 (+ b dist-sqrt))
                               (* 0.5 (- dist-sqrt b))))
                        #;(t0 (/ q a))
                        #;(t1 (/ c q)))
                   (let (#;(t (maximum t0 t1))
                         (t (/ (- (- 0 b) disc-sqrt)
                               (* 2 a))))
                     (if (< t 0)
                         (miss)
                         (let* ((pos (point-add (point-scale direction t)
                                                origin))
                                (norm (unit-length (point-diff pos center)))
                                (color (point-scale
                                        color
                                        (dot-prod light-dir norm))))
                           (hit t color))))))))))))

  (define (select-point scene origin dir)
    (inner-reduce select-closest
      (kernel ((shape scene))
        (intersect-shape shape origin dir (unit-length
                                           (point3f 1 1 -2))))))

  (define (color-point point)
    (match point
      ((miss) (point3f 1 1 1))
      ((hit dist color) color)))
  
  (define (select-coord axis point)
    (match point
      ((point3f x y z)
       (match axis
         ((XAxis) x)
         ((YAxis) y)
         ((ZAxis) z)))))
  
  (define (plane-intersection axis plane origin dir)
    (/ (- plane (select-coord axis origin)) (select-coord axis dir)))
  
  (define (traverse-kd-tree tree origin dir ray-bounds)
    (match tree
      ((Leaf shapes) (select-point shapes origin dir))
      ((Split axis plane left right)
       ;; Find where the ray intersects this plane
       (let ((t (plane-intersection axis plane origin dir)))
         (match ray-bounds
           ((FloatPair t0 t1)
            (if (>= t t0)
                (if (<= t t1)
                    (select-closest (traverse-kd-tree left origin dir
                                                      (FloatPair t0 t))
                                    (traverse-kd-tree right origin dir
                                                      (FloatPair t t1)))
                    (traverse-kd-tree left origin dir ray-bounds))
                (if (<= t t1)
                    (traverse-kd-tree right origin dir ray-bounds)
                    (miss)))))))))

  (define (render-tree tree origin width height)
    (interpolate-range
     (y 1.0 -1.0 height) ;; y coordinate is upside down.
     (interpolate-range
      (x -1.0 1.0 width)
      (let ((dir (unit-length (point3f x y 1))))
        (color-point (traverse-kd-tree tree origin dir
                                       ;; Arbitrarily set the vision distance
                                       (FloatPair 0 1000)))))))
  
  ;; render a bunch of shapes without using the kd-tree
  (define (render-direct scene origin width height)
    (interpolate-range
     (y 1.0 -1.0 height) ;; y coordinate is upside down.
     (interpolate-range
      (x -1.0 1.0 width)
      (let ((dir (unit-length (point3f x y 1))))
        (color-point (select-point scene origin dir)))))))
